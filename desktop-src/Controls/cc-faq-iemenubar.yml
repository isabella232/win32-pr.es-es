### YamlMime:FAQ
metadata:
  title: Cómo crear una barra de menús Explorer-Style Internet
  description: A primera vista, la barra de menús de Microsoft Internet Explorer 5 y versiones posteriores es similar a un menú estándar. Sin embargo, tiene un aspecto bastante diferente al empezar a usarlo.
  ms.assetid: e0fe25f2-3d49-4c5a-a3f9-2f468f2cfef2
  ms.topic: article
  ms.date: 05/31/2018
  ms.openlocfilehash: 8bc836c0c8060a1ad23926220cdcfa6f7b6e651f
  ms.sourcegitcommit: d75fc10b9f0825bbe5ce5045c90d4045e3c53243
  ms.translationtype: MT
  ms.contentlocale: es-ES
  ms.lasthandoff: 09/13/2021
  ms.locfileid: "127569793"
title: Cómo crear una barra de menús Explorer-Style Internet
summary: >
  A primera vista, la barra de menús de Microsoft Internet Explorer 5 y versiones posteriores es similar a un menú estándar. Sin embargo, tiene un aspecto bastante diferente al empezar a usarlo.


  En la siguiente captura de pantalla se muestra Windows Internet Explorer barra de menús con el menú Herramientas seleccionado.


  ![captura de pantalla que muestra la barra de menús de Windows Internet Explorer, con el menú herramientas seleccionado](images/howto8.jpg)


  La barra de menús es realmente un control de barra de herramientas que parece un menú estándar. En lugar de elementos de menú de nivel superior, una barra de menús tiene una serie de botones de solo texto que muestran un menú desplegable al hacer clic en él. Sin embargo, como tipo especializado de barra de herramientas, una barra de menús tiene algunas funcionalidades que carecen de los menús estándar:


  -   Se puede personalizar mediante técnicas de barra de herramientas estándar, lo que permite al usuario mover, eliminar o agregar elementos.

  -   Puede tener un seguimiento en caliente, para que los usuarios sepan cuándo están sobre un elemento de nivel superior sin tener que hacer clic primero en él.


  Una barra de menús se puede incorporar en un control rebar, lo que le proporciona las siguientes características:


  -   Puede tener un controlador, que permite al usuario mover o cambiar el tamaño de la banda.

  -   Puede compartir una franja en el control rebar con otras bandas, como la barra de herramientas estándar de la ilustración anterior.

  -   Puede mostrar un botón de contenido adicional cuando está cubierto por una banda adyacente, lo que proporciona al usuario acceso a los elementos ocultos.

  -   Puede tener un mapa de bits en segundo plano definido por la aplicación.


  En este tema se describe cómo implementar una barra de menús. Puesto que una barra de menús es una implementación especializada de un control de barra de herramientas, el foco estará en los temas específicos de las barras de menús. Para obtener una explicación sobre cómo incorporar una barra de herramientas en un control rebar, vea [How to Create an Internet Explorer-Style Toolbar](cc-faq-ietoolbar.yml) y About [Rebar Controls](rebar-controls.md).
sections:
- name: Omitido
  questions:
  - question: >
      Convertir una barra de herramientas en una barra de menús
    answer: "Para convertir una barra de herramientas en una barra de menús:\n\n-   Cree una barra de herramientas plana incluyendo [**TBSTYLE \\_ FLAT**](toolbar-control-and-button-styles.md) con las otras marcas de estilo de ventana. El **estilo TBSTYLE \\_ FLAT** también permite el seguimiento en caliente. Con este estilo, la barra de menús se parece mucho a un menú estándar hasta que el usuario activa un botón. A continuación, parece que el botón destaca de la barra de herramientas y se desprime cuando se hace clic en él, al igual que un botón estándar. Dado que el seguimiento activo está habilitado, todo lo que se necesita para activar un botón es que el cursor mantenga el puntero sobre él. Si el cursor se mueve a otro botón, se activará y se desactivará el botón anterior.\n-   Cree botones de estilo de lista mediante [**la inclusión de TBSTYLE \\_ LIST**](toolbar-control-and-button-styles.md) con las otras marcas de estilo de ventana. Este estilo crea un botón más pequeño que se parece más a un elemento de menú de nivel superior estándar.\n-   Haga que los botones solo usen texto estableciendo el miembro **iBitmap** de la estructura [**TBBUTTON**](/windows/desktop/api/Commctrl/ns-commctrl-tbbutton) del botón en I IMAGENONE y el miembro iString en el \\_ texto del botón. \n-   Dé a cada botón el [**estilo \\_ DESPLEGABLE BTNS.**](toolbar-control-and-button-styles.md) Cuando se hace clic en el botón, el control de barra de herramientas envía a la aplicación una notificación [DESPLEGABLE DE TBN \\_ ](tbn-dropdown.md) para solicitar que muestre el menú del botón.\n-   Incorpore la barra de menús a una banda de barra de rebar. Habilite los controles y los botones de contenido adicional, como se describe en Creación de una barra de [herramientas Explorer-Style Internet.](cc-faq-ietoolbar.yml)\n-   Implemente un controlador DE LISTA DESPLEGABLE [ \\_ DE TBN](tbn-dropdown.md) para mostrar el menú desplegable del botón *cuando* se haga clic en él. El menú desplegable es un tipo de menú emergente. Se crea mediante la función [**TrackPopupMenu,**](/windows/desktop/api/winuser/nf-winuser-trackpopupmenu) con su esquina superior izquierda alineada con la esquina inferior izquierda del botón.\n-   Implemente la navegación con el teclado para que la barra de menús sea totalmente accesible sin un mouse.\n-   Implemente el seguimiento rápido del menú. Con los menús estándar, una vez que se ha mostrado el menú de un elemento de menú de nivel superior, al mover el cursor sobre otro elemento de nivel superior se muestra automáticamente su menú y se contrae el menú del elemento anterior. El control de barra de herramientas realizará un seguimiento rápido del cursor y cambiará la imagen del botón, pero muestra automáticamente el nuevo menú. La aplicación debe hacerlo explícitamente.\n\nLa mayoría de estos elementos son fáciles de implementar y se analizan en otro lugar. Vea [How to Create an Internet Explorer-Style Toolbar](cc-faq-ietoolbar.yml), About Toolbar [Controls](toolbar-controls-overview.md)o [About Rebar Controls](rebar-controls.md) para obtener una explicación general sobre cómo usar barras de herramientas y controles rebar. Consulte [Menús](/windows/desktop/menurc/menus) para obtener una explicación de cómo controlar los menús emergentes. Los dos últimos elementos, la navegación mediante el teclado y el seguimiento de menús, se analizan en el resto de este tema.\n"
  - question: >
      Control de la navegación con menús Hot-Tracking deshabilitado
    answer: >
      Los usuarios pueden elegir navegar por la barra de menús con el mouse, el teclado o una combinación de ambos. Para implementar la navegación de la barra de menús, la aplicación debe controlar las notificaciones de la barra de herramientas y supervisar el mouse y el teclado. Esta tarea se puede dividir en dos partes distintas: con y sin seguimiento de menús. En esta sección se describe cómo controlar la navegación cuando no se muestra ningún menú y el seguimiento de menús no está habilitado.
  - question: >
      Navegación del mouse
    answer: >
      Si el seguimiento de menús está deshabilitado, puede tratar una barra de menús como una barra de herramientas normal. Si el usuario navega con un mouse, lo único que debe hacer la aplicación es controlar la [notificación \_ DESPLEGABLE de TBN.](tbn-dropdown.md) Cuando se reciba esta notificación, muestre el menú desplegable adecuado y habilite el seguimiento rápido del menú. A partir de ese momento, se encuentra en el menú seguimiento rápido que se describe en Control de la navegación con Hot-Tracking [habilitado.](#handling-navigation-with-menu-hot-tracking-enabled)


      Como se describe en [Navegación](#mixed-navigation)mixta, también debe controlar la notificación [ \_ HOTITEMCHANGE](tbn-hotitemchange.md) de TBN para realizar un seguimiento del botón activo. Esta notificación es irrelevante si el usuario solo navega con el mouse, pero es necesario cuando la navegación del mouse y el teclado se mezclan.
  - question: >
      Navegación mediante teclado
    answer: >
      Como se indicó en la sección anterior, el usuario puede realizar varias operaciones de navegación con el teclado cuando el seguimiento de menús está deshabilitado. Los controles de la barra de herramientas solo admiten la navegación mediante el teclado si tienen el foco. Tampoco controlan todas las pulsaciones de tecla necesarias para las barras de menú. La solución más sencilla para controlar la navegación mediante el teclado es procesar explícitamente los eventos de pulsación de teclas pertinentes.


      Si el seguimiento rápido del menú está deshabilitado, la aplicación debe controlar estos eventos de pulsación de tecla de la siguiente manera:


      -   Tecla F10. Active el primer botón con [**TB \_ SETHOTITEM**](tb-sethotitem.md).

      -   Teclas DE FLECHA IZQUIERDA y FLECHA DERECHA. Active el botón adyacente con [**TB \_ SETHOTITEM**](tb-sethotitem.md). Si el usuario intenta navegar fuera de cualquier extremo de la barra de menús, active el primer botón en el extremo opuesto.

      -   Tecla ESCAPE. Desactive el botón activo con [**TB \_ SETHOTITEM**](tb-sethotitem.md). La barra de menús debe devolverse al estado que tenía antes de activar el primer botón.

      -   Tecla alt:*tecla de* aceleración. Use el [**mensaje \_ MAPACCELERATOR de TB**](tb-mapaccelerator.md) para determinar a qué botón corresponde el carácter clave.  Muestre el menú desplegable del botón y habilite el seguimiento de menús en caliente.

      -   Tecla FLECHA ABAJO. Si un botón está activo pero no se ha mostrado ningún menú, muestre el menú del botón y habilite el seguimiento activo del menú.

      -   Tecla ENTRAR. Desactive el botón activo con [**TB \_ SETHOTITEM**](tb-sethotitem.md). La barra de menús debe devolverse al estado que tenía antes de activar el primer botón.
  - question: >
      Navegación mixta
    answer: >
      Los controladores de navegación del teclado descritos en la sección anterior básicamente hacen dos tareas: realizar un seguimiento del botón activo y mostrar el menú adecuado cuando se selecciona un botón. Estos controladores son suficientes siempre que el usuario navegue solo con el teclado. Sin embargo, los usuarios suelen mezclar la navegación con el teclado y el mouse. Por ejemplo, podrían activar el primer botón con la tecla F10, usar el mouse para activar otro botón y, a continuación, abrir su menú con la tecla FLECHA ABAJO. Si solo está supervisando las pulsaciones de tecla para realizar un seguimiento de la tecla activa, mostrará el menú incorrecto. También debe controlar la notificación [ \_ HOTITEMCHANGE de TBN](tbn-hotitemchange.md) para realizar un seguimiento preciso del botón activo.
  - question: >
      Control de la navegación con menús Hot-Tracking habilitado
    answer: >
      Cuando el seguimiento de menús está habilitado, la aplicación debe cambiar la forma en que responde a la navegación del usuario. Para replicar el comportamiento de los menús estándar, debe implementar explícitamente las siguientes características.


      Con la navegación del mouse:


      -   Si el usuario mueve el cursor sobre otro botón, ese menú aparece inmediatamente y el menú anterior desaparece.

      -   El seguimiento activo del menú permanece activo hasta que el usuario selecciona un comando o hace clic en un punto que no forma parte de la región del menú. Cualquiera de las acciones desactiva el seguimiento rápido del menú hasta que se hace clic en otro botón.

      -   Si el cursor se mueve fuera del menú, el menú desplegable actual permanece hasta que el cursor vuelve a moverse hacia o el usuario hace clic en un punto fuera del área cubierta por el menú. Si el cursor vuelve a un botón diferente al que se muestra actualmente, el menú antiguo se contrae y se muestra el nuevo menú.


      Con la navegación mediante el teclado:


      -   La tecla FLECHA DERECHA mueve el foco a la derecha. Si el elemento tiene un submenú, muestre el submenú. Si el elemento no tiene un submenú, contraiga el menú y los submenús, active el botón siguiente con [**TB \_ SETHOTITEM**](tb-sethotitem.md)y muestre el menú del botón adyacente. Si el último botón está activo cuando se recibe este mensaje, muestre el menú del primer botón.

      -   La tecla DE FLECHA IZQUIERDA mueve el foco a la izquierda. Si el elemento es un submenú, contraigalo y cambie el foco a su menú primario. Si el elemento no es un submenú, contraiga el menú, active el botón siguiente con [**TB \_ SETHOTITEM**](tb-sethotitem.md)y muestre el menú de ese botón.


      -   La tecla ESCAPE hace una copia de seguridad de la pantalla en un paso.
          -   Si se muestra un submenú, se contrae y el foco cambia al menú primario.
          -   Si se muestra el menú de un botón, se contrae y se deshabilita el seguimiento rápido del menú. El botón del elemento permanece activo.
          -   Si no se muestra ningún menú pero hay un botón activo, el botón se desactiva y se deshabilita el seguimiento activo del menú.
      -   Las teclas FLECHA ARRIBA y FLECHA ABAJO solo se usan para navegar dentro de un menú determinado.

      -   La tecla ENTRAR inicia el comando asociado a un elemento de menú. Si el elemento de menú tiene un submenú, la tecla ENTRAR lo muestra.


      Al igual que con el caso de seguimiento en caliente deshabilitado del menú, la aplicación debe ser capaz de controlar la navegación mixta, el teclado y el mouse. Sin embargo, el hecho de que se muestre un menú significa que la mensajería tendrá que administrarse de forma ligeramente diferente.
  - question: >
      Procesamiento de mensajes para el menú Hot-Tracking
    answer: >
      El seguimiento rápido de menús requiere que se muestre un menú en todo momento, además del breve intervalo necesario para cambiar a un nuevo menú. Sin embargo, el menú desplegable que muestra [**TrackPopupMenu**](/windows/desktop/api/winuser/nf-winuser-trackpopupmenu) es modal. La aplicación seguirá recibiendo algunos mensajes directamente, como [**WM \_ COMMAND**](/windows/desktop/menurc/wm-command), [TBN \_ HOTITEMCHANGE](tbn-hotitemchange.md)y mensajes normales relacionados con el menú, como [**WM \_ MENUSELECT**](/windows/desktop/menurc/wm-menuselect). Sin embargo, no recibirá directamente mensajes de teclado o mouse de bajo nivel. Para controlar mensajes como [**WM \_ MOUSEMOVE,**](/windows/desktop/inputdev/wm-mousemove)debe establecer un enlace de mensajes para interceptar los mensajes que se dirigen al menú.


      Cuando se muestre un menú desplegable, establezca el enlace de mensajes llamando a la función [**SetWindowsHookEx**](/windows/desktop/api/winuser/nf-winuser-setwindowshookexa) con el parámetro *idHook* establecido en WH \_ MSGFILTER. Todos los mensajes destinados al menú se pasarán al procedimiento [de enlace](/previous-versions/windows/desktop/legacy/ms644987(v=vs.85)). Por ejemplo, el siguiente fragmento de código establece un enlace de mensaje que capturará los mensajes que van a un menú desplegable. `MsgHook` es el nombre del procedimiento de enlace y `hhookMsg` es el identificador del procedimiento.


      ```

      hhookMsg = SetWindowsHookEx(WH_MSGFILTER, MsgHook, HINST_THISDLL, 0);

      ```


      Los mensajes de menú se identifican estableciendo el parámetro *nCode* del procedimiento de enlace en MSGF \_ MENU. El *parámetro lParam* apuntará a una [**estructura MSG**](/windows/win32/api/winuser/ns-winuser-msg) con el mensaje . Los detalles de los mensajes que se deben controlar y cómo se deban tratar en el resto de este tema.


      La aplicación debe pasar todos los mensajes al siguiente enlace de mensajes mediante una llamada a la [**función CallNextHookEx.**](/windows/desktop/api/winuser/nf-winuser-callnexthookex) También debe enviar mensajes del mouse directamente al control de barra de herramientas y asegurarse de convertir las coordenadas de punto en el espacio de coordenadas del cliente de la barra de herramientas. El envío directo de los mensajes garantiza que el control de barra de herramientas recibe los mensajes del mouse adecuados. Por ejemplo, la barra de herramientas debe recibir [**mensajes \_ WM MOUSEMOVE**](/windows/desktop/inputdev/wm-mousemove) para realizar un seguimiento rápido de sus botones.


      Cuando se activa un botón nuevo, la aplicación debe contraer el menú desplegable anterior con un mensaje [**\_ CANCELMODE**](/windows/desktop/winmsg/wm-cancelmode) de WM y mostrar un nuevo menú. También debe contraer el menú desplegable cuando se toma el foco desde la barra de menús con navegación con el teclado o haciendo clic fuera del área de menú. Cada vez que contrae un menú, debe liberar su enlace de mensajes mediante la función [**UnhookWindowsHookEx.**](/windows/desktop/api/winuser/nf-winuser-unhookwindowshookex) Si necesita mostrar otro menú desplegable, cree un nuevo enlace de mensajes. Cuando se inicia un comando, el menú se contrae automáticamente, pero debe liberar explícitamente el enlace de mensajes.


      En el ejemplo de código siguiente se libera el enlace de mensaje que se estableció en el ejemplo anterior.



      ```

      UnhookWindowsHookEx(hhookMsg);

      ```
  - question: >
      Navegación del mouse
    answer: >
      Cuando una barra de herramientas normal controla los botones de seguimiento activo, resalta el botón activo y envía a la aplicación una notificación [ \_ HOTITEMCHANGE TBN](tbn-hotitemchange.md) cada vez que se activa un botón nuevo. La aplicación es responsable de mostrar el menú desplegable adecuado. Así, debe:


      -   Controle [la notificación \_ HOTITEMCHANGE de TBN](tbn-hotitemchange.md) para realizar un seguimiento del botón activo. Cuando cambie el botón activo, contraiga el menú antiguo y cree uno nuevo.

      -   Controle [la notificación DESPLEGABLE \_ de TBN](tbn-dropdown.md) que se envía cuando se hace clic en un botón. A continuación, debe contraer el menú y deshabilitar el seguimiento rápido del menú. El botón permanece activo.

      -   Controle [**los mensajes WM \_ LBUTTONDOWN,**](/windows/desktop/inputdev/wm-lbuttondown) [**WM \_ RBUTTONDOWN**](/windows/desktop/inputdev/wm-rbuttondown)y [**WM \_ MOUSEMOVE**](/windows/desktop/inputdev/wm-mousemove) en el procedimiento de enlace de mensajes para realizar un seguimiento de la posición del mouse. Si se hace clic con el mouse fuera del área de menú, contraiga el menú desplegable actual, desactive el seguimiento de acceso rápido del menú y devuelva la barra de menús a su estado de desactivación previa.

      -   Cuando se inicia un comando de menú, deshabilite el seguimiento de menús en caliente. El menú se contraerá automáticamente, pero debe liberar explícitamente el enlace de mensajes.


      También debe controlar la mensajería relacionada con el menú, como el mensaje [**\_ WM INITMENUPOPUP**](/windows/desktop/menurc/wm-initmenupopup) que se envía cuando un elemento de menú necesita mostrar un submenú. Para obtener una explicación sobre cómo controlar estos mensajes, vea [Menús](/windows/desktop/menurc/menus).
  - question: >
      Navegación mediante teclado
    answer: "La aplicación debe procesar los mensajes de teclado en el procedimiento de enlace de mensajes y actuar sobre los que afectan al seguimiento rápido de menús. Se deben controlar las siguientes pulsaciones de tecla:\n\n-   Tecla ESCAPE. La tecla ESCAPE hace que la pantalla se muestre un nivel. Si se muestra un submenú, debe contraerse. Si se muestra el menú principal de un botón, conséptelo y deshabilite el seguimiento rápido del menú. El botón permanece activo.\n-   Tecla FLECHA DERECHA. Si el elemento tiene un submenú, se muestra. Si el elemento no tiene un submenú, contraiga el menú y los submenús, active el botón siguiente con [**TB \\_ SETHOTITEM**](tb-sethotitem.md)y muestre su menú. Si el último botón estaba activo cuando se recibió esta notificación, muestre el menú del primer botón.\n-   Tecla FLECHA IZQUIERDA. Si el elemento está en un submenú, contraigalo y cambie el foco a su menú primario. Si el elemento no es un submenú, contraiga el menú, active el botón adyacente con [**TB \\_ SETHOTITEM**](tb-sethotitem.md)y muestre su menú. Si el primer botón estaba activo cuando se recibió esta notificación, muestre el menú del último botón.\n-   Teclas DE FLECHA ARRIBA y FLECHA ABAJO. Estas claves se usan para navegar dentro de un menú, pero no afectan directamente al seguimiento rápido del menú.\n-   Tecla alt:*tecla de* aceleración. Use el [**mensaje \\_ MAPACCELERATOR de TB**](tb-mapaccelerator.md) para determinar a qué botón corresponde el carácter clave.  Si corresponde a un botón diferente al activo actualmente, contraiga el menú desplegable actual, active el nuevo botón con [**TB \\_ SETHOTITEM**](tb-sethotitem.md)y muestre el menú del botón adyacente. Si el *carácter Clave corresponde* al botón que se muestra actualmente, contraiga el menú desplegable y deshabilite el seguimiento rápido del menú. El botón debe permanecer activo.          \n"
